// Code generated by sqlc. DO NOT EDIT.
// source: project.sql

package pg

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createProject = `-- name: CreateProject :one
INSERT INTO project(owner, team_id, created_at, name) VALUES ($1, $2, $3, $4) RETURNING project_id, team_id, created_at, name, owner
`

type CreateProjectParams struct {
	Owner     uuid.UUID `json:"owner"`
	TeamID    uuid.UUID `json:"team_id"`
	CreatedAt time.Time `json:"created_at"`
	Name      string    `json:"name"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Owner,
		arg.TeamID,
		arg.CreatedAt,
		arg.Name,
	)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.Owner,
	)
	return i, err
}

const deleteProjectByID = `-- name: DeleteProjectByID :exec
DELETE FROM project WHERE project_id = $1
`

func (q *Queries) DeleteProjectByID(ctx context.Context, projectID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProjectByID, projectID)
	return err
}

const getAllProjects = `-- name: GetAllProjects :many
SELECT project_id, team_id, created_at, name, owner FROM project
`

func (q *Queries) GetAllProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getAllProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsForTeam = `-- name: GetAllProjectsForTeam :many
SELECT project_id, team_id, created_at, name, owner FROM project WHERE team_id = $1
`

func (q *Queries) GetAllProjectsForTeam(ctx context.Context, teamID uuid.UUID) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getAllProjectsForTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.TeamID,
			&i.CreatedAt,
			&i.Name,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT project_id, team_id, created_at, name, owner FROM project WHERE project_id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, projectID uuid.UUID) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, projectID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.Owner,
	)
	return i, err
}

const updateProjectNameByID = `-- name: UpdateProjectNameByID :one
UPDATE project SET name = $2 WHERE project_id = $1 RETURNING project_id, team_id, created_at, name, owner
`

type UpdateProjectNameByIDParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Name      string    `json:"name"`
}

func (q *Queries) UpdateProjectNameByID(ctx context.Context, arg UpdateProjectNameByIDParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectNameByID, arg.ProjectID, arg.Name)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.TeamID,
		&i.CreatedAt,
		&i.Name,
		&i.Owner,
	)
	return i, err
}
