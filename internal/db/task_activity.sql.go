// Code generated by sqlc. DO NOT EDIT.
// source: task_activity.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createTaskActivity = `-- name: CreateTaskActivity :one
INSERT INTO task_activity (task_id, caused_by, created_at, activity_type_id, data)
  VALUES ($1, $2, $3, $4, $5) RETURNING task_activity_id, active, task_id, created_at, caused_by, activity_type_id, data
`

type CreateTaskActivityParams struct {
	TaskID         uuid.UUID       `json:"task_id"`
	CausedBy       uuid.UUID       `json:"caused_by"`
	CreatedAt      time.Time       `json:"created_at"`
	ActivityTypeID int32           `json:"activity_type_id"`
	Data           json.RawMessage `json:"data"`
}

func (q *Queries) CreateTaskActivity(ctx context.Context, arg CreateTaskActivityParams) (TaskActivity, error) {
	row := q.db.QueryRowContext(ctx, createTaskActivity,
		arg.TaskID,
		arg.CausedBy,
		arg.CreatedAt,
		arg.ActivityTypeID,
		arg.Data,
	)
	var i TaskActivity
	err := row.Scan(
		&i.TaskActivityID,
		&i.Active,
		&i.TaskID,
		&i.CreatedAt,
		&i.CausedBy,
		&i.ActivityTypeID,
		&i.Data,
	)
	return i, err
}

const getActivityForTaskID = `-- name: GetActivityForTaskID :many
SELECT task_activity_id, active, task_id, created_at, caused_by, activity_type_id, data FROM task_activity WHERE task_id = $1 AND active = true
`

func (q *Queries) GetActivityForTaskID(ctx context.Context, taskID uuid.UUID) ([]TaskActivity, error) {
	rows, err := q.db.QueryContext(ctx, getActivityForTaskID, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskActivity
	for rows.Next() {
		var i TaskActivity
		if err := rows.Scan(
			&i.TaskActivityID,
			&i.Active,
			&i.TaskID,
			&i.CreatedAt,
			&i.CausedBy,
			&i.ActivityTypeID,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastMoveForTaskID = `-- name: GetLastMoveForTaskID :one
SELECT active, created_at, data->>'CurTaskGroupID' AS cur_task_group_id, data->>'PrevTaskGroupID' AS prev_task_group_id FROM task_activity
  WHERE task_id = $1 AND activity_type_id = 2 AND created_at >= NOW() - INTERVAL '5 minutes'
ORDER BY created_at DESC LIMIT 1
`

type GetLastMoveForTaskIDRow struct {
	Active          bool        `json:"active"`
	CreatedAt       time.Time   `json:"created_at"`
	CurTaskGroupID  interface{} `json:"cur_task_group_id"`
	PrevTaskGroupID interface{} `json:"prev_task_group_id"`
}

func (q *Queries) GetLastMoveForTaskID(ctx context.Context, taskID uuid.UUID) (GetLastMoveForTaskIDRow, error) {
	row := q.db.QueryRowContext(ctx, getLastMoveForTaskID, taskID)
	var i GetLastMoveForTaskIDRow
	err := row.Scan(
		&i.Active,
		&i.CreatedAt,
		&i.CurTaskGroupID,
		&i.PrevTaskGroupID,
	)
	return i, err
}

const getTemplateForActivityID = `-- name: GetTemplateForActivityID :one
SELECT template FROM task_activity_type WHERE task_activity_type_id = $1
`

func (q *Queries) GetTemplateForActivityID(ctx context.Context, taskActivityTypeID int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getTemplateForActivityID, taskActivityTypeID)
	var template string
	err := row.Scan(&template)
	return template, err
}

const setInactiveLastMoveForTaskID = `-- name: SetInactiveLastMoveForTaskID :exec
UPDATE task_activity SET active = false WHERE task_activity_id = (
  SELECT task_activity_id FROM task_activity AS ta
  WHERE ta.activity_type_id = 2 AND ta.task_id = $1
  AND ta.created_at >= NOW() - INTERVAL '5 minutes'
  ORDER BY created_at DESC LIMIT 1
)
`

func (q *Queries) SetInactiveLastMoveForTaskID(ctx context.Context, taskID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setInactiveLastMoveForTaskID, taskID)
	return err
}
